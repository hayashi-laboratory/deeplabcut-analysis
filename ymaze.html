<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyDLCbehavior.ymaze API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyDLCbehavior.ymaze</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from dataclasses import dataclass, field
from numbers import Number
from typing import (
    Any,
    Dict,
    Generator,
    Hashable,
    List,
    NamedTuple,
    OrderedDict,
    Tuple,
    Union,
)

import cv2
import matplotlib as mpl
import numpy as np
from matplotlib.patches import Polygon
from math import sqrt

__all__ = [
    &#34;Point&#34;,
    &#34;Line&#34;,
    &#34;sort_coordinates&#34;,
    &#34;PixelScaler&#34;,
    &#34;YMazeScaler&#34;,
    &#34;ArmRegion&#34;,
    &#34;ArmCollection&#34;,
    &#34;BasicYMazeCollection&#34;,
]


SQRT3 = sqrt(3)


class Point(NamedTuple):
    x: Number = np.nan
    y: Number = np.nan

    def __add__(self, other: &#34;Point&#34;):
        if not isinstance(other, self.__class__):
            raise NotImplementedError()
        return Point(self.x + other.x, self.y + other.y)

    def __sub__(self, other: &#34;Point&#34;):
        if not isinstance(other, self.__class__):
            raise NotImplementedError()
        return Point(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar):
        if not isinstance(scalar, Number):
            raise NotImplementedError()
        return Point(self.x * scalar, self.y * scalar)

    def __neg__(self):
        return Point(self.x * (-1), self.y * (-1))

    def __repr__(self):
        return f&#34;Point(x={self.x:.2f},y={self.y:.2f})&#34;


def P(r: float, theta: float, origin=(0, 0)) -&gt; Point:
    &#34;&#34;&#34;Get x, y coordinate by radius and length

    Args:
        r (float): distance to origin
        theta (float): rotation degree from axis-x (deg)

    Returns:
        Point: x, y point
    &#34;&#34;&#34;
    from math import cos, sin, radians

    x = np.round(cos(radians(theta)) * r + origin[0], 3)
    y = np.round(sin(radians(theta)) * r + origin[1], 3)
    return Point(x, y)


def sort_coordinates(
    points: Union[List[Tuple[Number, Number]], np.ndarray],
) -&gt; np.ndarray:
    &#34;&#34;&#34;Sort the point collections in clock-wise order

    Args:
        points (Union[List[Tuple[Number,Number], np.ndarray]): A list or numpy array that contains (N, 2) of points

    Raises:
        ValueError: if input size is not (N, 2)

    Returns:
        np.ndarray: a numpy array of sorted points coordinates
    &#34;&#34;&#34;
    if isinstance(points, list):
        points = np.array(points)

    if points.ndim != 2 and points[1] != 2:
        raise ValueError(f&#34;input size{points.shape} is not (N, 2)&#34;)

    sub_np = points - points.mean(axis=0)
    degree = -np.degrees(np.arctan2(sub_np[:, 1], sub_np[:, 0])) - 135
    degree = np.mod(degree, 360)
    return points[degree.argsort()].astype(np.float32)


@dataclass(frozen=True)
class Line:

    pt1: Point = field(default_factory=Point)
    pt2: Point = field(default_factory=Point)

    def __post_init__(self):
        object.__setattr__(self, &#34;pt1&#34;, Point(*self.pt1))
        object.__setattr__(self, &#34;pt2&#34;, Point(*self.pt2))

    def __getstate__(self):
        return dict(pt1=self.pt1, pt2=self.pt2)

    def __setstate__(self, d):
        self.__dict__.update(d)

    @property
    def slope(self):
        return np.Inf if self.xdiff == 0 else self.ydiff / self.xdiff

    @property
    def middle_pt(self) -&gt; Point:
        x1, y1, x2, y2 = self.pt1, self.pt2
        return Point((x1 + x2) / 2, (y1 + y2) / 2)

    @property
    def dist(self):
        from math import pow, sqrt

        return sqrt(pow(self.xdiff, 2), pow(self.ydiff, 2))

    @property
    def constant(self):
        m = self.slope
        x1, y1 = self.pt1
        if m == 0:
            return y1
        if m == np.Inf:
            return np.nan
        return y1 - m * x1

    @property
    def xdiff(self):
        return self.pt1[0] - self.pt2[0]

    @property
    def ydiff(self):
        return self.pt1[1] - self.pt2[1]

    def __call__(self, x: float) -&gt; float:
        if self.slope == np.Inf:
            return np.Inf
        if self.slope == 0:
            return 0
        return self.slope * x + self.constant

    def draw_line(self, ax, *args, **kwargs):
        array = np.array([self.pt1, self.pt2])
        # print(&#34;self.pt1 is &#34;, array[0, :])
        ax.plot(array[:, 0], array[:, 1], *args, **kwargs)

    def cal_intersection(self, other: &#34;Line&#34;) -&gt; Point:
        &#34;&#34;&#34;
        Calcuate the intersection point of two lines.
        If vertical_cross is True, calculate the intersection point of orthogonal lines from two lines, that passed the median point.
        :otherlines Line:
        :vertical_cross Bool:
        :RETURN (x, y) Tuple:
        &#34;&#34;&#34;
        xdiff = self.xdiff, other.xdiff
        ydiff = self.ydiff, other.ydiff

        def det(a, b):
            return a[0] * b[1] - a[1] * b[0]

        div = det(xdiff, ydiff)
        if div == 0:
            return Point()

        d = (det(self.pt1, self.pt2), det(other.pt1, other.pt2))
        x = det(d, xdiff) / div
        y = det(d, ydiff) / div
        return Point(x, y)


@dataclass
class PixelScaler:
    target: List[Tuple[int, int]]
    reference: List[Tuple[int, int]]
    warp_mat: np.ndarray = field(init=False, default=np.array([(1, 0, 0), (0, 1, 0)]))

    def __post_init__(self):
        target_num = len(self.target)
        ref_num = len(self.reference)
        if (ref_num != target_num) or (ref_num &lt; 2) or (len(self.reference[0]) != 2):
            raise ValueError(
                f&#34;shape are not (N, 2), N &gt; 1.\ntarget   : {self.target}\nreference: {self.reference}&#34;
            )

        ref_np = sort_coordinates(self.reference)
        target_np = sort_coordinates(self.target)

        if ref_num == 2:
            ref_diff = np.abs(ref_np[1] - ref_np[0])
            target_dff = np.abs(target_np[1] - target_np[0])
            scale = ref_diff / target_dff
            self.warp_mat *= scale[None, :]
        else:
            step = (ref_num - 3) // 2 + 1
            self.warp_mat = cv2.getAffineTransform(target_np[::step], ref_np[::step])

        self.reference = list(map(tuple, ref_np))
        self.target = list(map(tuple, target_np))

    def scale(self, xy_coords: Union[np.ndarray, List[Point]]) -&gt; np.ndarray:
        &#34;&#34;&#34;Re-scale the xy-coordinates from target scale to reference scale.

        Args:
            xy_coords (np.ndarray): A xy-coordinate array with shape (..., 2)
        Raises:
            TypeError: ndim &gt; 1 and array.shape[-1]

        Returns:
            np.ndarray: Return the rescale value (..., 2)
        &#34;&#34;&#34;
        if not isinstance(xy_coords, np.ndarray):
            xy_coords = np.array(xy_coords)
        shape = xy_coords.shape
        ndim = xy_coords.ndim
        if ndim &lt; 2 or shape[-1] != 2:
            raise TypeError(f&#34;src shape{xy_coords.shape} is not (N, 2) or (M, N, 2)&#34;)
        pad_width = [(0, 0) for _ in range(ndim - 1)]
        pad_width.append((0, 1))
        return np.pad(xy_coords, pad_width=pad_width, constant_values=1).dot(
            self.warp_mat.T
        )


@dataclass
class YMazeScaler(PixelScaler):

    reference: List[Tuple[int, int]] = field(init=False)

    def __post_init__(self):
        r = 35 + 6 / SQRT3
        self.reference = np.array([P(r, 150), P(r, 270), P(r, 30)])
        super().__post_init__()


@dataclass
class ArmRegion:

    name: str = &#34;&#34;
    points: List[Point] = field(default_factory=list)

    def __post_init__(self):
        if len(self.points):
            self.sort()

    def __setstate__(self, d):
        self.__dict__.update(d)

    def __getstate__(self) -&gt; Dict[str, Any]:
        return dict(name=self.name, points=self.points)

    @property
    def center(self) -&gt; None:
        if not len(self.points):
            return Point()
        return Point(*np.array(self.points).mean(axis=0))

    def is_valid(self, x, y) -&gt; bool:
        if x is None or y is None:
            return False
        if np.isnan(x) or np.isnan(y):
            return False
        return True

    def get_paired_lines(self) -&gt; List[Line]:
        num = len(self.points)
        if not num:
            return list()
        return [Line(self.points[i - 1], self.points[i]) for i in range(num)]

    def sort(self):
        self.points = [tuple(pt) for pt in sort_coordinates(self.points)]

    def add_point(self, x: int, y: int):
        &#34;&#34;&#34;Add a new point to area corner

        Args:
            x (int): x-coordinates
            y (int): y-coordinates

        Raises:
            ValueError: Value should be numeric and not nan.
        &#34;&#34;&#34;
        if not self.is_valid(x, y):
            raise ValueError(f&#34;invalid value ({x}, {y})&#34;)
        self.points.append(Point(x, y))
        self.sort()

    def add_points(self, xy_coords: List[Point]):
        self.points.extend([Point(*pt) for pt in xy_coords])
        self.sort()

    def contains(self, x: float, y: float) -&gt; bool:
        &#34;&#34;&#34;A function to check whether point is in Arm area (closed)

        Args:
            x (float): x-coordinates
            y (float): y-coordinates
        &#34;&#34;&#34;
        if len(self.points) &lt; 3:
            return False
        polygon = mpl.path.Path(self.points)
        return polygon.contains_point((x, y))

    def draw_area(self, ax, *args, **kwargs) -&gt; None:
        if not self.points:
            return
        poly = Polygon(self.points, *args, **kwargs)
        ax.add_patch(poly)

    def merge(self, other: &#34;ArmRegion&#34;) -&gt; &#34;ArmRegion&#34;:
        if not isinstance(other, self.__class__):
            raise NotImplementedError()
        self.points.extend(other.points)
        self.sort()
        return self

    def copy(self) -&gt; &#34;ArmRegion&#34;:
        r = ArmRegion(self.name)
        r.points = [p for p in self.points]
        return r


@dataclass
class ArmCollection:

    data: OrderedDict[str, ArmRegion] = field(default_factory=OrderedDict)
    area: ArmRegion = field(init=False, repr=False, default_factory=ArmRegion)

    @property
    def center(self):
        return self.area.center

    @property
    def each_arm_center(self):
        return [a.center for a in self.data.values()]

    def __getstate__(self):
        return dict(data=self.data, area=self.area)

    def __setstate__(self, d):
        self.__dict__.update(d)

    def __len__(self):
        return len(self.data)

    def __getitem__(self, key: Hashable):
        return self.data[key]

    def __iter__(self) -&gt; Generator[ArmRegion, None, None]:
        for key in self.data.keys():
            yield key

    def keys(self) -&gt; Generator[str, None, None]:
        return self.data.keys()

    def values(self) -&gt; Generator[ArmRegion, None, None]:
        return self.data.values()

    def items(self) -&gt; Generator[Tuple[str, ArmRegion], None, None]:
        return self.data.items()

    def get(self, key, default=None):
        return self.data.get(key, default)

    def remove(self, item: Any) -&gt; None:
        self.data = OrderedDict([(k, v) for k, v in self.data.items() if v != item])

    def append(self, arm_region: ArmRegion):
        if not isinstance(arm_region, ArmRegion):
            raise NotImplementedError
        self.data[arm_region.name] = arm_region
        self.area.merge(arm_region)

    def sort(self) -&gt; None:
        self.area.sort()

    def draw_contour(self, ax, *arg, **kwargs):
        poly = Polygon(self.area.points, *arg, **kwargs)
        ax.add_patch(poly)

    # def get_ymaze_verts_by_coords(self):
    #     lines = self.area.get_paired_lines()
    #     center = np.array(self.center)
    #     is_close = lambda pt: 1e4 &gt; np.sum(np.square(np.array(pt) - center))
    #     temp = self.area.copy()
    #     for i in range(len(lines)):
    #         l1 = lines[i - 2]
    #         l2 = lines[i]
    #         x, y = l1.cal_intersection(l2)
    #         if is_close((x, y)):
    #             temp.add_point(x, y)
    #     return temp.points


@dataclass
class BasicYMazeCollection(ArmCollection):
    def __post_init__(self):
        r = 12 / SQRT3
        p1, p2, p3 = P(r, 90), P(r, 210), P(r, 330)
        a1, a2, a3, a4 = P(30, 150, p2), P(40, 150, p2), P(40, 150, p1), P(30, 150, p1)
        b1, b2, b3, b4 = P(30, 30, p1), P(40, 30, p1), P(40, 30, p3), P(30, 30, p3)
        c1, c2, c3, c4 = P(30, 270, p3), P(40, 270, p3), P(40, 270, p2), P(30, 270, p2)
        o_pts = [p1, p2, p3]
        a_pts = [a1, a2, a3, a4]
        b_pts = [b1, b2, b3, b4]
        c_pts = [c1, c2, c3, c4]
        all_pts = o_pts + a_pts + b_pts + c_pts
        self.data = OrderedDict(
            A=ArmRegion(&#34;A&#34;, a_pts),
            B=ArmRegion(&#34;B&#34;, b_pts),
            C=ArmRegion(&#34;C&#34;, c_pts),
        )
        self.area.points = all_pts
        self.sort()

    def fit(
        self,
        reference_points: List[Point],
    ) -&gt; None:
        &#34;&#34;&#34;Fit the mask of YMaze to the center of 3 arms.
        Args:
            reference_points (List[Point]): The reference center points with the order [ArmA, ArmB, ArmC]
        &#34;&#34;&#34;
        s = PixelScaler(self.each_arm_center, reference_points)
        np2pts = lambda l: [Point(*p) for p in l]
        for v in self.data.values():
            v.points = np2pts(s.scale(v.points))
        self.area.points = np2pts(s.scale(self.area.points))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyDLCbehavior.ymaze.sort_coordinates"><code class="name flex">
<span>def <span class="ident">sort_coordinates</span></span>(<span>points: Union[List[Tuple[numbers.Number, numbers.Number]], numpy.ndarray]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Sort the point collections in clock-wise order</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>Union[List[Tuple[Number,Number], np.ndarray]</code></dt>
<dd>A list or numpy array that contains (N, 2) of points</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>if input size is not (N, 2)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>a numpy array of sorted points coordinates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_coordinates(
    points: Union[List[Tuple[Number, Number]], np.ndarray],
) -&gt; np.ndarray:
    &#34;&#34;&#34;Sort the point collections in clock-wise order

    Args:
        points (Union[List[Tuple[Number,Number], np.ndarray]): A list or numpy array that contains (N, 2) of points

    Raises:
        ValueError: if input size is not (N, 2)

    Returns:
        np.ndarray: a numpy array of sorted points coordinates
    &#34;&#34;&#34;
    if isinstance(points, list):
        points = np.array(points)

    if points.ndim != 2 and points[1] != 2:
        raise ValueError(f&#34;input size{points.shape} is not (N, 2)&#34;)

    sub_np = points - points.mean(axis=0)
    degree = -np.degrees(np.arctan2(sub_np[:, 1], sub_np[:, 0])) - 135
    degree = np.mod(degree, 360)
    return points[degree.argsort()].astype(np.float32)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyDLCbehavior.ymaze.ArmCollection"><code class="flex name class">
<span>class <span class="ident">ArmCollection</span></span>
<span>(</span><span>data: OrderedDict[str, <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a>] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>ArmCollection(data: OrderedDict[str, pyDLCbehavior.ymaze.ArmRegion] = <factory>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ArmCollection:

    data: OrderedDict[str, ArmRegion] = field(default_factory=OrderedDict)
    area: ArmRegion = field(init=False, repr=False, default_factory=ArmRegion)

    @property
    def center(self):
        return self.area.center

    @property
    def each_arm_center(self):
        return [a.center for a in self.data.values()]

    def __getstate__(self):
        return dict(data=self.data, area=self.area)

    def __setstate__(self, d):
        self.__dict__.update(d)

    def __len__(self):
        return len(self.data)

    def __getitem__(self, key: Hashable):
        return self.data[key]

    def __iter__(self) -&gt; Generator[ArmRegion, None, None]:
        for key in self.data.keys():
            yield key

    def keys(self) -&gt; Generator[str, None, None]:
        return self.data.keys()

    def values(self) -&gt; Generator[ArmRegion, None, None]:
        return self.data.values()

    def items(self) -&gt; Generator[Tuple[str, ArmRegion], None, None]:
        return self.data.items()

    def get(self, key, default=None):
        return self.data.get(key, default)

    def remove(self, item: Any) -&gt; None:
        self.data = OrderedDict([(k, v) for k, v in self.data.items() if v != item])

    def append(self, arm_region: ArmRegion):
        if not isinstance(arm_region, ArmRegion):
            raise NotImplementedError
        self.data[arm_region.name] = arm_region
        self.area.merge(arm_region)

    def sort(self) -&gt; None:
        self.area.sort()

    def draw_contour(self, ax, *arg, **kwargs):
        poly = Polygon(self.area.points, *arg, **kwargs)
        ax.add_patch(poly)

    # def get_ymaze_verts_by_coords(self):
    #     lines = self.area.get_paired_lines()
    #     center = np.array(self.center)
    #     is_close = lambda pt: 1e4 &gt; np.sum(np.square(np.array(pt) - center))
    #     temp = self.area.copy()
    #     for i in range(len(lines)):
    #         l1 = lines[i - 2]
    #         l2 = lines[i]
    #         x, y = l1.cal_intersection(l2)
    #         if is_close((x, y)):
    #             temp.add_point(x, y)
    #     return temp.points</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyDLCbehavior.ymaze.BasicYMazeCollection" href="#pyDLCbehavior.ymaze.BasicYMazeCollection">BasicYMazeCollection</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.ArmCollection.area"><code class="name">var <span class="ident">area</span> : <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmCollection.data"><code class="name">var <span class="ident">data</span> : OrderedDict[str, <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.ArmCollection.center"><code class="name">var <span class="ident">center</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self):
    return self.area.center</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmCollection.each_arm_center"><code class="name">var <span class="ident">each_arm_center</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def each_arm_center(self):
    return [a.center for a in self.data.values()]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.ArmCollection.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, arm_region: <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, arm_region: ArmRegion):
    if not isinstance(arm_region, ArmRegion):
        raise NotImplementedError
    self.data[arm_region.name] = arm_region
    self.area.merge(arm_region)</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmCollection.draw_contour"><code class="name flex">
<span>def <span class="ident">draw_contour</span></span>(<span>self, ax, *arg, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_contour(self, ax, *arg, **kwargs):
    poly = Polygon(self.area.points, *arg, **kwargs)
    ax.add_patch(poly)</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmCollection.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key, default=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, key, default=None):
    return self.data.get(key, default)</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmCollection.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self) ‑> Generator[Tuple[str, <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a>], None, None]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self) -&gt; Generator[Tuple[str, ArmRegion], None, None]:
    return self.data.items()</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmCollection.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self) ‑> Generator[str, None, None]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self) -&gt; Generator[str, None, None]:
    return self.data.keys()</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmCollection.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, item: Any) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, item: Any) -&gt; None:
    self.data = OrderedDict([(k, v) for k, v in self.data.items() if v != item])</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmCollection.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self) -&gt; None:
    self.area.sort()</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmCollection.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self) ‑> Generator[<a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a>, None, None]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self) -&gt; Generator[ArmRegion, None, None]:
    return self.data.values()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion"><code class="flex name class">
<span>class <span class="ident">ArmRegion</span></span>
<span>(</span><span>name: str = '', points: List[<a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a>] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>ArmRegion(name: str = '', points: List[pyDLCbehavior.ymaze.Point] = <factory>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ArmRegion:

    name: str = &#34;&#34;
    points: List[Point] = field(default_factory=list)

    def __post_init__(self):
        if len(self.points):
            self.sort()

    def __setstate__(self, d):
        self.__dict__.update(d)

    def __getstate__(self) -&gt; Dict[str, Any]:
        return dict(name=self.name, points=self.points)

    @property
    def center(self) -&gt; None:
        if not len(self.points):
            return Point()
        return Point(*np.array(self.points).mean(axis=0))

    def is_valid(self, x, y) -&gt; bool:
        if x is None or y is None:
            return False
        if np.isnan(x) or np.isnan(y):
            return False
        return True

    def get_paired_lines(self) -&gt; List[Line]:
        num = len(self.points)
        if not num:
            return list()
        return [Line(self.points[i - 1], self.points[i]) for i in range(num)]

    def sort(self):
        self.points = [tuple(pt) for pt in sort_coordinates(self.points)]

    def add_point(self, x: int, y: int):
        &#34;&#34;&#34;Add a new point to area corner

        Args:
            x (int): x-coordinates
            y (int): y-coordinates

        Raises:
            ValueError: Value should be numeric and not nan.
        &#34;&#34;&#34;
        if not self.is_valid(x, y):
            raise ValueError(f&#34;invalid value ({x}, {y})&#34;)
        self.points.append(Point(x, y))
        self.sort()

    def add_points(self, xy_coords: List[Point]):
        self.points.extend([Point(*pt) for pt in xy_coords])
        self.sort()

    def contains(self, x: float, y: float) -&gt; bool:
        &#34;&#34;&#34;A function to check whether point is in Arm area (closed)

        Args:
            x (float): x-coordinates
            y (float): y-coordinates
        &#34;&#34;&#34;
        if len(self.points) &lt; 3:
            return False
        polygon = mpl.path.Path(self.points)
        return polygon.contains_point((x, y))

    def draw_area(self, ax, *args, **kwargs) -&gt; None:
        if not self.points:
            return
        poly = Polygon(self.points, *args, **kwargs)
        ax.add_patch(poly)

    def merge(self, other: &#34;ArmRegion&#34;) -&gt; &#34;ArmRegion&#34;:
        if not isinstance(other, self.__class__):
            raise NotImplementedError()
        self.points.extend(other.points)
        self.sort()
        return self

    def copy(self) -&gt; &#34;ArmRegion&#34;:
        r = ArmRegion(self.name)
        r.points = [p for p in self.points]
        return r</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.ArmRegion.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion.points"><code class="name">var <span class="ident">points</span> : List[<a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.ArmRegion.center"><code class="name">var <span class="ident">center</span> : None</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def center(self) -&gt; None:
    if not len(self.points):
        return Point()
    return Point(*np.array(self.points).mean(axis=0))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.ArmRegion.add_point"><code class="name flex">
<span>def <span class="ident">add_point</span></span>(<span>self, x: int, y: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new point to area corner</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>int</code></dt>
<dd>x-coordinates</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>int</code></dt>
<dd>y-coordinates</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Value should be numeric and not nan.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_point(self, x: int, y: int):
    &#34;&#34;&#34;Add a new point to area corner

    Args:
        x (int): x-coordinates
        y (int): y-coordinates

    Raises:
        ValueError: Value should be numeric and not nan.
    &#34;&#34;&#34;
    if not self.is_valid(x, y):
        raise ValueError(f&#34;invalid value ({x}, {y})&#34;)
    self.points.append(Point(x, y))
    self.sort()</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion.add_points"><code class="name flex">
<span>def <span class="ident">add_points</span></span>(<span>self, xy_coords: List[<a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_points(self, xy_coords: List[Point]):
    self.points.extend([Point(*pt) for pt in xy_coords])
    self.sort()</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion.contains"><code class="name flex">
<span>def <span class="ident">contains</span></span>(<span>self, x: float, y: float) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>A function to check whether point is in Arm area (closed)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>x-coordinates</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>y-coordinates</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contains(self, x: float, y: float) -&gt; bool:
    &#34;&#34;&#34;A function to check whether point is in Arm area (closed)

    Args:
        x (float): x-coordinates
        y (float): y-coordinates
    &#34;&#34;&#34;
    if len(self.points) &lt; 3:
        return False
    polygon = mpl.path.Path(self.points)
    return polygon.contains_point((x, y))</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self) ‑> <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self) -&gt; &#34;ArmRegion&#34;:
    r = ArmRegion(self.name)
    r.points = [p for p in self.points]
    return r</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion.draw_area"><code class="name flex">
<span>def <span class="ident">draw_area</span></span>(<span>self, ax, *args, **kwargs) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_area(self, ax, *args, **kwargs) -&gt; None:
    if not self.points:
        return
    poly = Polygon(self.points, *args, **kwargs)
    ax.add_patch(poly)</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion.get_paired_lines"><code class="name flex">
<span>def <span class="ident">get_paired_lines</span></span>(<span>self) ‑> List[<a title="pyDLCbehavior.ymaze.Line" href="#pyDLCbehavior.ymaze.Line">Line</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_paired_lines(self) -&gt; List[Line]:
    num = len(self.points)
    if not num:
        return list()
    return [Line(self.points[i - 1], self.points[i]) for i in range(num)]</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion.is_valid"><code class="name flex">
<span>def <span class="ident">is_valid</span></span>(<span>self, x, y) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid(self, x, y) -&gt; bool:
    if x is None or y is None:
        return False
    if np.isnan(x) or np.isnan(y):
        return False
    return True</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, other: <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a>) ‑> <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, other: &#34;ArmRegion&#34;) -&gt; &#34;ArmRegion&#34;:
    if not isinstance(other, self.__class__):
        raise NotImplementedError()
    self.points.extend(other.points)
    self.sort()
    return self</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.ArmRegion.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self):
    self.points = [tuple(pt) for pt in sort_coordinates(self.points)]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyDLCbehavior.ymaze.BasicYMazeCollection"><code class="flex name class">
<span>class <span class="ident">BasicYMazeCollection</span></span>
<span>(</span><span>data: OrderedDict[str, <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a>] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>BasicYMazeCollection(data: OrderedDict[str, pyDLCbehavior.ymaze.ArmRegion] = <factory>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class BasicYMazeCollection(ArmCollection):
    def __post_init__(self):
        r = 12 / SQRT3
        p1, p2, p3 = P(r, 90), P(r, 210), P(r, 330)
        a1, a2, a3, a4 = P(30, 150, p2), P(40, 150, p2), P(40, 150, p1), P(30, 150, p1)
        b1, b2, b3, b4 = P(30, 30, p1), P(40, 30, p1), P(40, 30, p3), P(30, 30, p3)
        c1, c2, c3, c4 = P(30, 270, p3), P(40, 270, p3), P(40, 270, p2), P(30, 270, p2)
        o_pts = [p1, p2, p3]
        a_pts = [a1, a2, a3, a4]
        b_pts = [b1, b2, b3, b4]
        c_pts = [c1, c2, c3, c4]
        all_pts = o_pts + a_pts + b_pts + c_pts
        self.data = OrderedDict(
            A=ArmRegion(&#34;A&#34;, a_pts),
            B=ArmRegion(&#34;B&#34;, b_pts),
            C=ArmRegion(&#34;C&#34;, c_pts),
        )
        self.area.points = all_pts
        self.sort()

    def fit(
        self,
        reference_points: List[Point],
    ) -&gt; None:
        &#34;&#34;&#34;Fit the mask of YMaze to the center of 3 arms.
        Args:
            reference_points (List[Point]): The reference center points with the order [ArmA, ArmB, ArmC]
        &#34;&#34;&#34;
        s = PixelScaler(self.each_arm_center, reference_points)
        np2pts = lambda l: [Point(*p) for p in l]
        for v in self.data.values():
            v.points = np2pts(s.scale(v.points))
        self.area.points = np2pts(s.scale(self.area.points))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyDLCbehavior.ymaze.ArmCollection" href="#pyDLCbehavior.ymaze.ArmCollection">ArmCollection</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.BasicYMazeCollection.area"><code class="name">var <span class="ident">area</span> : <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.ymaze.BasicYMazeCollection.data"><code class="name">var <span class="ident">data</span> : OrderedDict[str, <a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.BasicYMazeCollection.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>self, reference_points: List[<a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a>]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Fit the mask of YMaze to the center of 3 arms.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reference_points</code></strong> :&ensp;<code>List[<a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a>]</code></dt>
<dd>The reference center points with the order [ArmA, ArmB, ArmC]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit(
    self,
    reference_points: List[Point],
) -&gt; None:
    &#34;&#34;&#34;Fit the mask of YMaze to the center of 3 arms.
    Args:
        reference_points (List[Point]): The reference center points with the order [ArmA, ArmB, ArmC]
    &#34;&#34;&#34;
    s = PixelScaler(self.each_arm_center, reference_points)
    np2pts = lambda l: [Point(*p) for p in l]
    for v in self.data.values():
        v.points = np2pts(s.scale(v.points))
    self.area.points = np2pts(s.scale(self.area.points))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyDLCbehavior.ymaze.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>pt1: <a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a> = &lt;factory&gt;, pt2: <a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a> = &lt;factory&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Line(pt1: pyDLCbehavior.ymaze.Point = <factory>, pt2: pyDLCbehavior.ymaze.Point = <factory>)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class Line:

    pt1: Point = field(default_factory=Point)
    pt2: Point = field(default_factory=Point)

    def __post_init__(self):
        object.__setattr__(self, &#34;pt1&#34;, Point(*self.pt1))
        object.__setattr__(self, &#34;pt2&#34;, Point(*self.pt2))

    def __getstate__(self):
        return dict(pt1=self.pt1, pt2=self.pt2)

    def __setstate__(self, d):
        self.__dict__.update(d)

    @property
    def slope(self):
        return np.Inf if self.xdiff == 0 else self.ydiff / self.xdiff

    @property
    def middle_pt(self) -&gt; Point:
        x1, y1, x2, y2 = self.pt1, self.pt2
        return Point((x1 + x2) / 2, (y1 + y2) / 2)

    @property
    def dist(self):
        from math import pow, sqrt

        return sqrt(pow(self.xdiff, 2), pow(self.ydiff, 2))

    @property
    def constant(self):
        m = self.slope
        x1, y1 = self.pt1
        if m == 0:
            return y1
        if m == np.Inf:
            return np.nan
        return y1 - m * x1

    @property
    def xdiff(self):
        return self.pt1[0] - self.pt2[0]

    @property
    def ydiff(self):
        return self.pt1[1] - self.pt2[1]

    def __call__(self, x: float) -&gt; float:
        if self.slope == np.Inf:
            return np.Inf
        if self.slope == 0:
            return 0
        return self.slope * x + self.constant

    def draw_line(self, ax, *args, **kwargs):
        array = np.array([self.pt1, self.pt2])
        # print(&#34;self.pt1 is &#34;, array[0, :])
        ax.plot(array[:, 0], array[:, 1], *args, **kwargs)

    def cal_intersection(self, other: &#34;Line&#34;) -&gt; Point:
        &#34;&#34;&#34;
        Calcuate the intersection point of two lines.
        If vertical_cross is True, calculate the intersection point of orthogonal lines from two lines, that passed the median point.
        :otherlines Line:
        :vertical_cross Bool:
        :RETURN (x, y) Tuple:
        &#34;&#34;&#34;
        xdiff = self.xdiff, other.xdiff
        ydiff = self.ydiff, other.ydiff

        def det(a, b):
            return a[0] * b[1] - a[1] * b[0]

        div = det(xdiff, ydiff)
        if div == 0:
            return Point()

        d = (det(self.pt1, self.pt2), det(other.pt1, other.pt2))
        x = det(d, xdiff) / div
        y = det(d, ydiff) / div
        return Point(x, y)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.Line.pt1"><code class="name">var <span class="ident">pt1</span> : <a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.ymaze.Line.pt2"><code class="name">var <span class="ident">pt2</span> : <a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.Line.constant"><code class="name">var <span class="ident">constant</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def constant(self):
    m = self.slope
    x1, y1 = self.pt1
    if m == 0:
        return y1
    if m == np.Inf:
        return np.nan
    return y1 - m * x1</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.Line.dist"><code class="name">var <span class="ident">dist</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dist(self):
    from math import pow, sqrt

    return sqrt(pow(self.xdiff, 2), pow(self.ydiff, 2))</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.Line.middle_pt"><code class="name">var <span class="ident">middle_pt</span> : <a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def middle_pt(self) -&gt; Point:
    x1, y1, x2, y2 = self.pt1, self.pt2
    return Point((x1 + x2) / 2, (y1 + y2) / 2)</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.Line.slope"><code class="name">var <span class="ident">slope</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def slope(self):
    return np.Inf if self.xdiff == 0 else self.ydiff / self.xdiff</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.Line.xdiff"><code class="name">var <span class="ident">xdiff</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def xdiff(self):
    return self.pt1[0] - self.pt2[0]</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.Line.ydiff"><code class="name">var <span class="ident">ydiff</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ydiff(self):
    return self.pt1[1] - self.pt2[1]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.Line.cal_intersection"><code class="name flex">
<span>def <span class="ident">cal_intersection</span></span>(<span>self, other: <a title="pyDLCbehavior.ymaze.Line" href="#pyDLCbehavior.ymaze.Line">Line</a>) ‑> <a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a></span>
</code></dt>
<dd>
<div class="desc"><p>Calcuate the intersection point of two lines.
If vertical_cross is True, calculate the intersection point of orthogonal lines from two lines, that passed the median point.
:otherlines Line:
:vertical_cross Bool:
:RETURN (x, y) Tuple:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cal_intersection(self, other: &#34;Line&#34;) -&gt; Point:
    &#34;&#34;&#34;
    Calcuate the intersection point of two lines.
    If vertical_cross is True, calculate the intersection point of orthogonal lines from two lines, that passed the median point.
    :otherlines Line:
    :vertical_cross Bool:
    :RETURN (x, y) Tuple:
    &#34;&#34;&#34;
    xdiff = self.xdiff, other.xdiff
    ydiff = self.ydiff, other.ydiff

    def det(a, b):
        return a[0] * b[1] - a[1] * b[0]

    div = det(xdiff, ydiff)
    if div == 0:
        return Point()

    d = (det(self.pt1, self.pt2), det(other.pt1, other.pt2))
    x = det(d, xdiff) / div
    y = det(d, ydiff) / div
    return Point(x, y)</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.ymaze.Line.draw_line"><code class="name flex">
<span>def <span class="ident">draw_line</span></span>(<span>self, ax, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_line(self, ax, *args, **kwargs):
    array = np.array([self.pt1, self.pt2])
    # print(&#34;self.pt1 is &#34;, array[0, :])
    ax.plot(array[:, 0], array[:, 1], *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyDLCbehavior.ymaze.PixelScaler"><code class="flex name class">
<span>class <span class="ident">PixelScaler</span></span>
<span>(</span><span>target: List[Tuple[int, int]], reference: List[Tuple[int, int]])</span>
</code></dt>
<dd>
<div class="desc"><p>PixelScaler(target: List[Tuple[int, int]], reference: List[Tuple[int, int]])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class PixelScaler:
    target: List[Tuple[int, int]]
    reference: List[Tuple[int, int]]
    warp_mat: np.ndarray = field(init=False, default=np.array([(1, 0, 0), (0, 1, 0)]))

    def __post_init__(self):
        target_num = len(self.target)
        ref_num = len(self.reference)
        if (ref_num != target_num) or (ref_num &lt; 2) or (len(self.reference[0]) != 2):
            raise ValueError(
                f&#34;shape are not (N, 2), N &gt; 1.\ntarget   : {self.target}\nreference: {self.reference}&#34;
            )

        ref_np = sort_coordinates(self.reference)
        target_np = sort_coordinates(self.target)

        if ref_num == 2:
            ref_diff = np.abs(ref_np[1] - ref_np[0])
            target_dff = np.abs(target_np[1] - target_np[0])
            scale = ref_diff / target_dff
            self.warp_mat *= scale[None, :]
        else:
            step = (ref_num - 3) // 2 + 1
            self.warp_mat = cv2.getAffineTransform(target_np[::step], ref_np[::step])

        self.reference = list(map(tuple, ref_np))
        self.target = list(map(tuple, target_np))

    def scale(self, xy_coords: Union[np.ndarray, List[Point]]) -&gt; np.ndarray:
        &#34;&#34;&#34;Re-scale the xy-coordinates from target scale to reference scale.

        Args:
            xy_coords (np.ndarray): A xy-coordinate array with shape (..., 2)
        Raises:
            TypeError: ndim &gt; 1 and array.shape[-1]

        Returns:
            np.ndarray: Return the rescale value (..., 2)
        &#34;&#34;&#34;
        if not isinstance(xy_coords, np.ndarray):
            xy_coords = np.array(xy_coords)
        shape = xy_coords.shape
        ndim = xy_coords.ndim
        if ndim &lt; 2 or shape[-1] != 2:
            raise TypeError(f&#34;src shape{xy_coords.shape} is not (N, 2) or (M, N, 2)&#34;)
        pad_width = [(0, 0) for _ in range(ndim - 1)]
        pad_width.append((0, 1))
        return np.pad(xy_coords, pad_width=pad_width, constant_values=1).dot(
            self.warp_mat.T
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyDLCbehavior.ymaze.YMazeScaler" href="#pyDLCbehavior.ymaze.YMazeScaler">YMazeScaler</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.PixelScaler.reference"><code class="name">var <span class="ident">reference</span> : List[Tuple[int, int]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.ymaze.PixelScaler.target"><code class="name">var <span class="ident">target</span> : List[Tuple[int, int]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.ymaze.PixelScaler.warp_mat"><code class="name">var <span class="ident">warp_mat</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.PixelScaler.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, xy_coords: Union[numpy.ndarray, List[<a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a>]]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Re-scale the xy-coordinates from target scale to reference scale.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>xy_coords</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A xy-coordinate array with shape (&hellip;, 2)</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>ndim &gt; 1 and array.shape[-1]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Return the rescale value (&hellip;, 2)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale(self, xy_coords: Union[np.ndarray, List[Point]]) -&gt; np.ndarray:
    &#34;&#34;&#34;Re-scale the xy-coordinates from target scale to reference scale.

    Args:
        xy_coords (np.ndarray): A xy-coordinate array with shape (..., 2)
    Raises:
        TypeError: ndim &gt; 1 and array.shape[-1]

    Returns:
        np.ndarray: Return the rescale value (..., 2)
    &#34;&#34;&#34;
    if not isinstance(xy_coords, np.ndarray):
        xy_coords = np.array(xy_coords)
    shape = xy_coords.shape
    ndim = xy_coords.ndim
    if ndim &lt; 2 or shape[-1] != 2:
        raise TypeError(f&#34;src shape{xy_coords.shape} is not (N, 2) or (M, N, 2)&#34;)
    pad_width = [(0, 0) for _ in range(ndim - 1)]
    pad_width.append((0, 1))
    return np.pad(xy_coords, pad_width=pad_width, constant_values=1).dot(
        self.warp_mat.T
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyDLCbehavior.ymaze.Point"><code class="flex name class">
<span>class <span class="ident">Point</span></span>
<span>(</span><span>x: numbers.Number = nan, y: numbers.Number = nan)</span>
</code></dt>
<dd>
<div class="desc"><p>Point(x, y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Point(NamedTuple):
    x: Number = np.nan
    y: Number = np.nan

    def __add__(self, other: &#34;Point&#34;):
        if not isinstance(other, self.__class__):
            raise NotImplementedError()
        return Point(self.x + other.x, self.y + other.y)

    def __sub__(self, other: &#34;Point&#34;):
        if not isinstance(other, self.__class__):
            raise NotImplementedError()
        return Point(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar):
        if not isinstance(scalar, Number):
            raise NotImplementedError()
        return Point(self.x * scalar, self.y * scalar)

    def __neg__(self):
        return Point(self.x * (-1), self.y * (-1))

    def __repr__(self):
        return f&#34;Point(x={self.x:.2f},y={self.y:.2f})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.Point.x"><code class="name">var <span class="ident">x</span> : numbers.Number</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
<dt id="pyDLCbehavior.ymaze.Point.y"><code class="name">var <span class="ident">y</span> : numbers.Number</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
</dl>
</dd>
<dt id="pyDLCbehavior.ymaze.YMazeScaler"><code class="flex name class">
<span>class <span class="ident">YMazeScaler</span></span>
<span>(</span><span>target: List[Tuple[int, int]])</span>
</code></dt>
<dd>
<div class="desc"><p>YMazeScaler(target: List[Tuple[int, int]])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class YMazeScaler(PixelScaler):

    reference: List[Tuple[int, int]] = field(init=False)

    def __post_init__(self):
        r = 35 + 6 / SQRT3
        self.reference = np.array([P(r, 150), P(r, 270), P(r, 30)])
        super().__post_init__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyDLCbehavior.ymaze.PixelScaler" href="#pyDLCbehavior.ymaze.PixelScaler">PixelScaler</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyDLCbehavior.ymaze.YMazeScaler.reference"><code class="name">var <span class="ident">reference</span> : List[Tuple[int, int]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyDLCbehavior.ymaze.PixelScaler" href="#pyDLCbehavior.ymaze.PixelScaler">PixelScaler</a></b></code>:
<ul class="hlist">
<li><code><a title="pyDLCbehavior.ymaze.PixelScaler.scale" href="#pyDLCbehavior.ymaze.PixelScaler.scale">scale</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyDLCbehavior" href="index.html">pyDLCbehavior</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyDLCbehavior.ymaze.sort_coordinates" href="#pyDLCbehavior.ymaze.sort_coordinates">sort_coordinates</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyDLCbehavior.ymaze.ArmCollection" href="#pyDLCbehavior.ymaze.ArmCollection">ArmCollection</a></code></h4>
<ul class="two-column">
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.append" href="#pyDLCbehavior.ymaze.ArmCollection.append">append</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.area" href="#pyDLCbehavior.ymaze.ArmCollection.area">area</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.center" href="#pyDLCbehavior.ymaze.ArmCollection.center">center</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.data" href="#pyDLCbehavior.ymaze.ArmCollection.data">data</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.draw_contour" href="#pyDLCbehavior.ymaze.ArmCollection.draw_contour">draw_contour</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.each_arm_center" href="#pyDLCbehavior.ymaze.ArmCollection.each_arm_center">each_arm_center</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.get" href="#pyDLCbehavior.ymaze.ArmCollection.get">get</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.items" href="#pyDLCbehavior.ymaze.ArmCollection.items">items</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.keys" href="#pyDLCbehavior.ymaze.ArmCollection.keys">keys</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.remove" href="#pyDLCbehavior.ymaze.ArmCollection.remove">remove</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.sort" href="#pyDLCbehavior.ymaze.ArmCollection.sort">sort</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmCollection.values" href="#pyDLCbehavior.ymaze.ArmCollection.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyDLCbehavior.ymaze.ArmRegion" href="#pyDLCbehavior.ymaze.ArmRegion">ArmRegion</a></code></h4>
<ul class="two-column">
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.add_point" href="#pyDLCbehavior.ymaze.ArmRegion.add_point">add_point</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.add_points" href="#pyDLCbehavior.ymaze.ArmRegion.add_points">add_points</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.center" href="#pyDLCbehavior.ymaze.ArmRegion.center">center</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.contains" href="#pyDLCbehavior.ymaze.ArmRegion.contains">contains</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.copy" href="#pyDLCbehavior.ymaze.ArmRegion.copy">copy</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.draw_area" href="#pyDLCbehavior.ymaze.ArmRegion.draw_area">draw_area</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.get_paired_lines" href="#pyDLCbehavior.ymaze.ArmRegion.get_paired_lines">get_paired_lines</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.is_valid" href="#pyDLCbehavior.ymaze.ArmRegion.is_valid">is_valid</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.merge" href="#pyDLCbehavior.ymaze.ArmRegion.merge">merge</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.name" href="#pyDLCbehavior.ymaze.ArmRegion.name">name</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.points" href="#pyDLCbehavior.ymaze.ArmRegion.points">points</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.ArmRegion.sort" href="#pyDLCbehavior.ymaze.ArmRegion.sort">sort</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyDLCbehavior.ymaze.BasicYMazeCollection" href="#pyDLCbehavior.ymaze.BasicYMazeCollection">BasicYMazeCollection</a></code></h4>
<ul class="">
<li><code><a title="pyDLCbehavior.ymaze.BasicYMazeCollection.area" href="#pyDLCbehavior.ymaze.BasicYMazeCollection.area">area</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.BasicYMazeCollection.data" href="#pyDLCbehavior.ymaze.BasicYMazeCollection.data">data</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.BasicYMazeCollection.fit" href="#pyDLCbehavior.ymaze.BasicYMazeCollection.fit">fit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyDLCbehavior.ymaze.Line" href="#pyDLCbehavior.ymaze.Line">Line</a></code></h4>
<ul class="two-column">
<li><code><a title="pyDLCbehavior.ymaze.Line.cal_intersection" href="#pyDLCbehavior.ymaze.Line.cal_intersection">cal_intersection</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Line.constant" href="#pyDLCbehavior.ymaze.Line.constant">constant</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Line.dist" href="#pyDLCbehavior.ymaze.Line.dist">dist</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Line.draw_line" href="#pyDLCbehavior.ymaze.Line.draw_line">draw_line</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Line.middle_pt" href="#pyDLCbehavior.ymaze.Line.middle_pt">middle_pt</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Line.pt1" href="#pyDLCbehavior.ymaze.Line.pt1">pt1</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Line.pt2" href="#pyDLCbehavior.ymaze.Line.pt2">pt2</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Line.slope" href="#pyDLCbehavior.ymaze.Line.slope">slope</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Line.xdiff" href="#pyDLCbehavior.ymaze.Line.xdiff">xdiff</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Line.ydiff" href="#pyDLCbehavior.ymaze.Line.ydiff">ydiff</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyDLCbehavior.ymaze.PixelScaler" href="#pyDLCbehavior.ymaze.PixelScaler">PixelScaler</a></code></h4>
<ul class="">
<li><code><a title="pyDLCbehavior.ymaze.PixelScaler.reference" href="#pyDLCbehavior.ymaze.PixelScaler.reference">reference</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.PixelScaler.scale" href="#pyDLCbehavior.ymaze.PixelScaler.scale">scale</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.PixelScaler.target" href="#pyDLCbehavior.ymaze.PixelScaler.target">target</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.PixelScaler.warp_mat" href="#pyDLCbehavior.ymaze.PixelScaler.warp_mat">warp_mat</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyDLCbehavior.ymaze.Point" href="#pyDLCbehavior.ymaze.Point">Point</a></code></h4>
<ul class="">
<li><code><a title="pyDLCbehavior.ymaze.Point.x" href="#pyDLCbehavior.ymaze.Point.x">x</a></code></li>
<li><code><a title="pyDLCbehavior.ymaze.Point.y" href="#pyDLCbehavior.ymaze.Point.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyDLCbehavior.ymaze.YMazeScaler" href="#pyDLCbehavior.ymaze.YMazeScaler">YMazeScaler</a></code></h4>
<ul class="">
<li><code><a title="pyDLCbehavior.ymaze.YMazeScaler.reference" href="#pyDLCbehavior.ymaze.YMazeScaler.reference">reference</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>