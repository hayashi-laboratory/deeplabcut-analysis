<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyDLCbehavior.dataset API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyDLCbehavior.dataset</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from dataclasses import dataclass, field
from datetime import timedelta
from pathlib import Path
from typing import Any, Dict, Mapping, NamedTuple, Optional, Union

import cv2
import pandas as pd
from numpy import ndarray

__all__ = [&#34;DLCDataset&#34;, &#34;FrameDimension&#34;]


class FrameDimension(NamedTuple):
    width: int = -1
    height: int = -1


@dataclass
class DLCDataset:
    # file path
    csv_path: Path
    pkl_path: Path
    video_path: Path = field(default=&#34;&#34;)
    homedir: Path = field(init=False)

    # pickle data
    hyperparams: Dict[str, Any] = field(init=False, repr=False, default=None)
    dlc_model_config: Dict[str, Any] = field(init=False, repr=False, default=None)
    # video parameters
    FPS: float = field(init=False, default=None)
    frame_dimensions: FrameDimension = field(init=False, default_factory=FrameDimension)

    # raw_data
    raw_data: pd.DataFrame = field(init=False, repr=False, default=None)
    video_frame_cache: Optional[ndarray] =  field(init=False, repr =False, default = None)

    def __post_init__(self):
        # convert all path to patlib.Path
        self.csv_path = Path(self.csv_path)
        if not self.csv_path.exists():
            raise FileNotFoundError(self.csv_path)
        self.pkl_path = Path(self.pkl_path)
        if not self.pkl_path.exists():
            raise FileNotFoundError(self.pkl_path)
        self.video_path = Path(self.video_path)
        self.homedir = self.csv_path.parent

        # load pickle file that generate from DeepLabCut
        data: dict = pd.read_pickle(self.pkl_path).get(&#34;data&#34;, dict())

        if &#34;DLC-model-config file&#34; in data:
            self.dlc_model_config = data[&#34;DLC-model-config file&#34;]
            del data[&#34;DLC-model-config file&#34;]
        # load the video data from data
        self.FPS = data.get(&#34;fps&#34;)

        height, width = data.get(&#34;frame_dimensions&#34;, (-1, -1))

        self.frame_dimensions = FrameDimension(width, height)
        self.hyperparams = data

        # read a video frame and store as cache if video exists()
        self.read_video_frame()
        # load csv file
        self.load_csv()

    def __setstate__(self, d: Mapping[str, Any]) -&gt; None:
        &#34;&#34;&#34;A function that called when unpickling the NorDlcAnalysis class

        Args:
            d (Mapping[str, int]): data to be unpickled
        &#34;&#34;&#34;

        # convert all path and file dir into pathlib.Path
        for key, val in d.items():
            if not isinstance(val, str):
                continue
            if key.lower().endswith((&#34;path&#34;, &#34;dir&#34;)):
                d[key] = Path(val)
        # convert the string path to pathlib.Path
        self.__dict__.update(d)

    def __getstate__(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Called when pickleing the DLC Dataset

        Returns:
            Dict[str, int]: dict to be pickled
        &#34;&#34;&#34;
        return dict(
            csv_path=str(self.csv_path),
            pkl_path=str(self.pkl_path),
            video_path=str(self.video_path),
            homedir=str(self.homedir),
            hyperparams=self.hyperparams,
            dlc_model_config=self.dlc_model_config,
            FPS=self.FPS,
            frame_dimensions=self.frame_dimensions,
            raw_data=self.raw_data,
            video_frame_cache = self.video_frame_cache,
        )

    def load_csv(self) -&gt; None:
        &#34;&#34;&#34;Load the csv file and add a timestamp index&#34;&#34;&#34;
        # load data
        if self.csv_path.suffix in [&#34;.xlsx&#34;, &#34;.xls&#34;]:
            raw = pd.read_excel(self.csv_path, header=[0, 1, 2], index_col=0)
        else:
            raw = pd.read_csv(self.csv_path, header=[0, 1, 2], index_col=0)
        # Add timestamp index to raw data
        frame_interval = timedelta(milliseconds=1e3 / self.FPS)
        raw.index = raw.index * frame_interval
        self.raw_data = raw

    def to_pickle(self, pickle_path=None) -&gt; Path:
        if pickle_path is None:
            pickle_path = self.homedir.joinpath(f&#34;{self.csv_path.stem}_analysis.pkl.gz&#34;)
        else:
            pickle_path = Path(pickle_path)

        if pickle_path.suffix != &#34;.gz&#34;:
            pickle_path = pickle_path.with_name(pickle_path.name + &#34;.gz&#34;)

        print(&#34;Saving...&#34;)
        pd.to_pickle(self, pickle_path)
        print(f&#34;Compressed pickle was saved at \033[92m{pickle_path}\033[0m.&#34;)
        return pickle_path

    @staticmethod
    def from_pickle(pickle_path: Union[str, Path]):
        if not Path(pickle_path).exists():
            raise FileNotFoundError(str(pickle_path))
        return pd.read_pickle(Path(pickle_path))


    def read_video_frame(self) -&gt;None:
        if not (self.video_path.exists() and self.video_path.is_file()):
            return
        try:
            cap = cv2.VideoCapture(str(self.video_path))
            if not cap.isOpened():
                return
            # read 10 frame for cache video frame
            for _ in range(10):
                ok, frame = cap.read()
                if ok:
                    self.video_frame_cache = frame
                    break
        finally:
            cap.release()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyDLCbehavior.dataset.DLCDataset"><code class="flex name class">
<span>class <span class="ident">DLCDataset</span></span>
<span>(</span><span>csv_path: pathlib.Path, pkl_path: pathlib.Path, video_path: pathlib.Path = '')</span>
</code></dt>
<dd>
<div class="desc"><p>DLCDataset(csv_path: pathlib.Path, pkl_path: pathlib.Path, video_path: pathlib.Path = '')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class DLCDataset:
    # file path
    csv_path: Path
    pkl_path: Path
    video_path: Path = field(default=&#34;&#34;)
    homedir: Path = field(init=False)

    # pickle data
    hyperparams: Dict[str, Any] = field(init=False, repr=False, default=None)
    dlc_model_config: Dict[str, Any] = field(init=False, repr=False, default=None)
    # video parameters
    FPS: float = field(init=False, default=None)
    frame_dimensions: FrameDimension = field(init=False, default_factory=FrameDimension)

    # raw_data
    raw_data: pd.DataFrame = field(init=False, repr=False, default=None)
    video_frame_cache: Optional[ndarray] =  field(init=False, repr =False, default = None)

    def __post_init__(self):
        # convert all path to patlib.Path
        self.csv_path = Path(self.csv_path)
        if not self.csv_path.exists():
            raise FileNotFoundError(self.csv_path)
        self.pkl_path = Path(self.pkl_path)
        if not self.pkl_path.exists():
            raise FileNotFoundError(self.pkl_path)
        self.video_path = Path(self.video_path)
        self.homedir = self.csv_path.parent

        # load pickle file that generate from DeepLabCut
        data: dict = pd.read_pickle(self.pkl_path).get(&#34;data&#34;, dict())

        if &#34;DLC-model-config file&#34; in data:
            self.dlc_model_config = data[&#34;DLC-model-config file&#34;]
            del data[&#34;DLC-model-config file&#34;]
        # load the video data from data
        self.FPS = data.get(&#34;fps&#34;)

        height, width = data.get(&#34;frame_dimensions&#34;, (-1, -1))

        self.frame_dimensions = FrameDimension(width, height)
        self.hyperparams = data

        # read a video frame and store as cache if video exists()
        self.read_video_frame()
        # load csv file
        self.load_csv()

    def __setstate__(self, d: Mapping[str, Any]) -&gt; None:
        &#34;&#34;&#34;A function that called when unpickling the NorDlcAnalysis class

        Args:
            d (Mapping[str, int]): data to be unpickled
        &#34;&#34;&#34;

        # convert all path and file dir into pathlib.Path
        for key, val in d.items():
            if not isinstance(val, str):
                continue
            if key.lower().endswith((&#34;path&#34;, &#34;dir&#34;)):
                d[key] = Path(val)
        # convert the string path to pathlib.Path
        self.__dict__.update(d)

    def __getstate__(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Called when pickleing the DLC Dataset

        Returns:
            Dict[str, int]: dict to be pickled
        &#34;&#34;&#34;
        return dict(
            csv_path=str(self.csv_path),
            pkl_path=str(self.pkl_path),
            video_path=str(self.video_path),
            homedir=str(self.homedir),
            hyperparams=self.hyperparams,
            dlc_model_config=self.dlc_model_config,
            FPS=self.FPS,
            frame_dimensions=self.frame_dimensions,
            raw_data=self.raw_data,
            video_frame_cache = self.video_frame_cache,
        )

    def load_csv(self) -&gt; None:
        &#34;&#34;&#34;Load the csv file and add a timestamp index&#34;&#34;&#34;
        # load data
        if self.csv_path.suffix in [&#34;.xlsx&#34;, &#34;.xls&#34;]:
            raw = pd.read_excel(self.csv_path, header=[0, 1, 2], index_col=0)
        else:
            raw = pd.read_csv(self.csv_path, header=[0, 1, 2], index_col=0)
        # Add timestamp index to raw data
        frame_interval = timedelta(milliseconds=1e3 / self.FPS)
        raw.index = raw.index * frame_interval
        self.raw_data = raw

    def to_pickle(self, pickle_path=None) -&gt; Path:
        if pickle_path is None:
            pickle_path = self.homedir.joinpath(f&#34;{self.csv_path.stem}_analysis.pkl.gz&#34;)
        else:
            pickle_path = Path(pickle_path)

        if pickle_path.suffix != &#34;.gz&#34;:
            pickle_path = pickle_path.with_name(pickle_path.name + &#34;.gz&#34;)

        print(&#34;Saving...&#34;)
        pd.to_pickle(self, pickle_path)
        print(f&#34;Compressed pickle was saved at \033[92m{pickle_path}\033[0m.&#34;)
        return pickle_path

    @staticmethod
    def from_pickle(pickle_path: Union[str, Path]):
        if not Path(pickle_path).exists():
            raise FileNotFoundError(str(pickle_path))
        return pd.read_pickle(Path(pickle_path))


    def read_video_frame(self) -&gt;None:
        if not (self.video_path.exists() and self.video_path.is_file()):
            return
        try:
            cap = cv2.VideoCapture(str(self.video_path))
            if not cap.isOpened():
                return
            # read 10 frame for cache video frame
            for _ in range(10):
                ok, frame = cap.read()
                if ok:
                    self.video_frame_cache = frame
                    break
        finally:
            cap.release()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyDLCbehavior.analysis.NovelObjectRecognitionAnalysis" href="analysis.html#pyDLCbehavior.analysis.NovelObjectRecognitionAnalysis">NovelObjectRecognitionAnalysis</a></li>
<li><a title="pyDLCbehavior.analysis.YMazeAnalysis" href="analysis.html#pyDLCbehavior.analysis.YMazeAnalysis">YMazeAnalysis</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyDLCbehavior.dataset.DLCDataset.FPS"><code class="name">var <span class="ident">FPS</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.csv_path"><code class="name">var <span class="ident">csv_path</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.dlc_model_config"><code class="name">var <span class="ident">dlc_model_config</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.frame_dimensions"><code class="name">var <span class="ident">frame_dimensions</span> : <a title="pyDLCbehavior.dataset.FrameDimension" href="#pyDLCbehavior.dataset.FrameDimension">FrameDimension</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.homedir"><code class="name">var <span class="ident">homedir</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.hyperparams"><code class="name">var <span class="ident">hyperparams</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.pkl_path"><code class="name">var <span class="ident">pkl_path</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.raw_data"><code class="name">var <span class="ident">raw_data</span> : pandas.core.frame.DataFrame</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.video_frame_cache"><code class="name">var <span class="ident">video_frame_cache</span> : Optional[numpy.ndarray]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.video_path"><code class="name">var <span class="ident">video_path</span> : pathlib.Path</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyDLCbehavior.dataset.DLCDataset.from_pickle"><code class="name flex">
<span>def <span class="ident">from_pickle</span></span>(<span>pickle_path: Union[str, pathlib.Path])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_pickle(pickle_path: Union[str, Path]):
    if not Path(pickle_path).exists():
        raise FileNotFoundError(str(pickle_path))
    return pd.read_pickle(Path(pickle_path))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyDLCbehavior.dataset.DLCDataset.load_csv"><code class="name flex">
<span>def <span class="ident">load_csv</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Load the csv file and add a timestamp index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_csv(self) -&gt; None:
    &#34;&#34;&#34;Load the csv file and add a timestamp index&#34;&#34;&#34;
    # load data
    if self.csv_path.suffix in [&#34;.xlsx&#34;, &#34;.xls&#34;]:
        raw = pd.read_excel(self.csv_path, header=[0, 1, 2], index_col=0)
    else:
        raw = pd.read_csv(self.csv_path, header=[0, 1, 2], index_col=0)
    # Add timestamp index to raw data
    frame_interval = timedelta(milliseconds=1e3 / self.FPS)
    raw.index = raw.index * frame_interval
    self.raw_data = raw</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.read_video_frame"><code class="name flex">
<span>def <span class="ident">read_video_frame</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_video_frame(self) -&gt;None:
    if not (self.video_path.exists() and self.video_path.is_file()):
        return
    try:
        cap = cv2.VideoCapture(str(self.video_path))
        if not cap.isOpened():
            return
        # read 10 frame for cache video frame
        for _ in range(10):
            ok, frame = cap.read()
            if ok:
                self.video_frame_cache = frame
                break
    finally:
        cap.release()</code></pre>
</details>
</dd>
<dt id="pyDLCbehavior.dataset.DLCDataset.to_pickle"><code class="name flex">
<span>def <span class="ident">to_pickle</span></span>(<span>self, pickle_path=None) ‑> pathlib.Path</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_pickle(self, pickle_path=None) -&gt; Path:
    if pickle_path is None:
        pickle_path = self.homedir.joinpath(f&#34;{self.csv_path.stem}_analysis.pkl.gz&#34;)
    else:
        pickle_path = Path(pickle_path)

    if pickle_path.suffix != &#34;.gz&#34;:
        pickle_path = pickle_path.with_name(pickle_path.name + &#34;.gz&#34;)

    print(&#34;Saving...&#34;)
    pd.to_pickle(self, pickle_path)
    print(f&#34;Compressed pickle was saved at \033[92m{pickle_path}\033[0m.&#34;)
    return pickle_path</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyDLCbehavior.dataset.FrameDimension"><code class="flex name class">
<span>class <span class="ident">FrameDimension</span></span>
<span>(</span><span>width: int = -1, height: int = -1)</span>
</code></dt>
<dd>
<div class="desc"><p>FrameDimension(width, height)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrameDimension(NamedTuple):
    width: int = -1
    height: int = -1</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.tuple</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyDLCbehavior.dataset.FrameDimension.height"><code class="name">var <span class="ident">height</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 1</p></div>
</dd>
<dt id="pyDLCbehavior.dataset.FrameDimension.width"><code class="name">var <span class="ident">width</span> : int</code></dt>
<dd>
<div class="desc"><p>Alias for field number 0</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyDLCbehavior" href="index.html">pyDLCbehavior</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyDLCbehavior.dataset.DLCDataset" href="#pyDLCbehavior.dataset.DLCDataset">DLCDataset</a></code></h4>
<ul class="two-column">
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.FPS" href="#pyDLCbehavior.dataset.DLCDataset.FPS">FPS</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.csv_path" href="#pyDLCbehavior.dataset.DLCDataset.csv_path">csv_path</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.dlc_model_config" href="#pyDLCbehavior.dataset.DLCDataset.dlc_model_config">dlc_model_config</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.frame_dimensions" href="#pyDLCbehavior.dataset.DLCDataset.frame_dimensions">frame_dimensions</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.from_pickle" href="#pyDLCbehavior.dataset.DLCDataset.from_pickle">from_pickle</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.homedir" href="#pyDLCbehavior.dataset.DLCDataset.homedir">homedir</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.hyperparams" href="#pyDLCbehavior.dataset.DLCDataset.hyperparams">hyperparams</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.load_csv" href="#pyDLCbehavior.dataset.DLCDataset.load_csv">load_csv</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.pkl_path" href="#pyDLCbehavior.dataset.DLCDataset.pkl_path">pkl_path</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.raw_data" href="#pyDLCbehavior.dataset.DLCDataset.raw_data">raw_data</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.read_video_frame" href="#pyDLCbehavior.dataset.DLCDataset.read_video_frame">read_video_frame</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.to_pickle" href="#pyDLCbehavior.dataset.DLCDataset.to_pickle">to_pickle</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.video_frame_cache" href="#pyDLCbehavior.dataset.DLCDataset.video_frame_cache">video_frame_cache</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.DLCDataset.video_path" href="#pyDLCbehavior.dataset.DLCDataset.video_path">video_path</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyDLCbehavior.dataset.FrameDimension" href="#pyDLCbehavior.dataset.FrameDimension">FrameDimension</a></code></h4>
<ul class="">
<li><code><a title="pyDLCbehavior.dataset.FrameDimension.height" href="#pyDLCbehavior.dataset.FrameDimension.height">height</a></code></li>
<li><code><a title="pyDLCbehavior.dataset.FrameDimension.width" href="#pyDLCbehavior.dataset.FrameDimension.width">width</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>